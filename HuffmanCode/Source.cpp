#include "Huffman_tree.h"
#define encode_output "output_encode.txt"
#define decode_output "decoding.txt"
#define filename_input "input.txt"
using namespace std;

class BitStreamWriter {
private:
	std::ofstream outFile;
	unsigned char buffer; // ????? ??? ?????????? ?????
	int bitsInBuffer;     // ?????????? ?????, ??? ??????????? ? ??????

public:
	BitStreamWriter(const std::string& filename) : outFile(filename, std::ios::binary), buffer(0), bitsInBuffer(0) {}

	~BitStreamWriter() {
		flush(); // ????????, ??? ??? ???? ???????? ????? ????????? ?????
		outFile.close();
	}

	// ?????? ???? (0 ??? 1) ? ?????
	void writeBit(int bit) {
		buffer |= (bit & 1) << (7 - bitsInBuffer); // ???????? ???? ? ?????
		bitsInBuffer++;

		if (bitsInBuffer == 8) {
			flush(); // ???? ????? ?????, ?????????? ???? ? ????
		}
	}

	// ????? ?????? ? ????
	void flush() {
		if (bitsInBuffer > 0) {
			outFile.write(reinterpret_cast<char*>(&buffer), 1); // ?????? ?????? ? ????
			buffer = 0;
			bitsInBuffer = 0;
		}
	}
};

string get_data(string filename)
{
	string text;
	fstream input;
	input.open(filename, ios::in);
	while (!input.eof())
	{
		string temp;
		getline(input, temp);
		if (!input.eof())
		{
			temp += '\n';
		}
		text += temp;
	}
	input.close();
	return text;
}

/* ???????? ???????? */
string get_repeat(string text)
{
	string abc;
	bool exit_flag = 0;
	abc.push_back(text[0]);
	for (int i = 1; i < text.size(); i++)
	{
		exit_flag = 0;
		for (int j = 0; j < abc.size(); j++)
		{
			if (abc[j] == text[i])						//???? ? ????? ???????? ??? ???? ????? ?????
			{
				exit_flag = 1;							//???????, ???? ????? ????? ?????
				break;
			}
		}
		if (exit_flag == 1)								//???? ?? ???????? ????? ?????
		{
			continue;									//????????? ?? ????????? ???????? ??? ????. ?????
		}
		else											//???? ????? ??????? ?? ????
		{
			abc.push_back(text[i]);
			continue;
		}
	}
	return abc;
}

/* ????????? ??????? ??????? ????????????? ???????? */
void get_frequency(string text, int* frequencies, string abc)
{
	for (int i = 0; i < abc.size(); i++)
	{
		frequencies[i] = 0;
	}
	for (int j = 0; j < abc.size(); j++)
	{
		for (int i = 0; i < text.size(); i++)
		{
			if (abc[j] == text[i])
			{
				frequencies[j]++;
			}
		}
	}
}




int main()
{
	string text;
	text = get_data(filename_input);


	/* ???????? ?????? ?????? */
	string abc = get_repeat(text);
	int* frequencies = new int[abc.size()];
	get_frequency(text, frequencies, abc);

	cout << "Alphabet: " << abc << endl;
	cout << "Size of Alphabet: " << abc.size() << endl;
	cout << "Character Frequencies:" << endl;
	for (size_t i = 0; i < abc.size(); i++) {
		cout << abc[i] << ": " << frequencies[i] << endl;
	}

	/* ????????? ??????????: ???? ?????? */
	bool flag_ex = 0;
	if (abc.size() < 2)
	{
		flag_ex = !flag_ex;
	}

	huffman_coding encoding;
	encoding.HuffmanCodes(abc, frequencies, flag_ex);
	std::string encodedText = encoding.get_encode();


	BitStreamWriter writer(encode_output);
	for (char bit : encodedText) {
		writer.writeBit(bit - '0'); // ??????????? ?????? ? ????? (0 ??? 1)
	}
	writer.flush(); // ????? ?????????? ????? ? ????

	/* ??????????? */
	
	cout << endl << "Char: Code" << endl;
	unordered_map<char, string> huffman_code = encoding.get_huffman_code();
	for (char c : abc) {
		cout << c << ": " << huffman_code[c] << endl;
	}

	double entropy = encoding.calculate_entropy(abc, frequencies);
	cout << "Entropy: " << entropy << endl;

	delete[] frequencies;

	string temp = encoding.get_encode();


	/* ?????????????? */
	temp = encoding.decode_text(temp, flag_ex);
	encoding.set_decode(temp);
	encoding.output_file(decode_output, false);

	encoding.output_file(encode_output, true);

	return 0;
}